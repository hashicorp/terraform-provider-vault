// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package vault

import (
	"context"
	"fmt"
	"log"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"

	"github.com/hashicorp/terraform-provider-vault/internal/consts"
	"github.com/hashicorp/terraform-provider-vault/internal/provider"
	"github.com/hashicorp/terraform-provider-vault/util"
)

var (
	approleAuthBackendRoleBackendFromPathRegex = regexp.MustCompile("^auth/(.+)/role/.+$")
	approleAuthBackendRoleNameFromPathRegex    = regexp.MustCompile("^auth/.+/role/(.+)$")
)

func approleAuthBackendRoleResource() *schema.Resource {
	fields := map[string]*schema.Schema{
		consts.FieldRoleName: {
			Type:        schema.TypeString,
			Required:    true,
			Description: "Name of the role.",
			ForceNew:    true,
		},
		consts.FieldRoleID: {
			Type:        schema.TypeString,
			Optional:    true,
			Computed:    true,
			Description: "The RoleID of the role. Autogenerated if not set.",
		},
		consts.FieldBindSecretID: {
			Type:        schema.TypeBool,
			Optional:    true,
			Default:     true,
			Description: "Whether or not to require secret_id to be present when logging in using this AppRole.",
		},
		consts.FieldSecretIDBoundCIDRs: {
			Type:        schema.TypeSet,
			Optional:    true,
			Description: "List of CIDR blocks that can log in using the AppRole.",
			Elem: &schema.Schema{
				Type: schema.TypeString,
			},
		},
		consts.FieldSecretIDNumUses: {
			Type:        schema.TypeInt,
			Optional:    true,
			Description: "Number of times which a particular SecretID can be used to fetch a token from this AppRole, after which the SecretID will expire. Leaving this unset or setting it to 0 will allow unlimited uses.",
		},
		consts.FieldSecretIDTTL: {
			Type:        schema.TypeInt,
			Optional:    true,
			Description: "Number of seconds a SecretID remains valid for.",
		},
		consts.FieldLocalSecretIDs: {
			Type:        schema.TypeBool,
			Optional:    true,
			Description: "If true, SecretIDs generated against this role will be 'local' to the node they were generated on. This means that they will only be valid when used against the same node that they were generated on.",
			Default:     false,
		},
		consts.FieldBackend: {
			Type:        schema.TypeString,
			Optional:    true,
			Description: "Unique name of the auth backend to configure.",
			ForceNew:    true,
			Default:     "approle",
			// standardise on no beginning or trailing slashes
			StateFunc: func(v interface{}) string {
				return strings.Trim(v.(string), "/")
			},
		},
	}

	addTokenFields(fields, &addTokenFieldsConfig{})

	return &schema.Resource{
		CreateContext: approleAuthBackendRoleCreate,
		ReadContext:   provider.ReadContextWrapper(approleAuthBackendRoleRead),
		UpdateContext: approleAuthBackendRoleUpdate,
		DeleteContext: approleAuthBackendRoleDelete,
		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},
		Schema: fields,
	}
}

func approleAuthBackendRoleUpdateFields(d *schema.ResourceData, data map[string]interface{}, create bool) {
	updateTokenFields(d, data, create)

	if create {
		if v, ok := d.GetOkExists(consts.FieldBindSecretID); ok {
			data[consts.FieldBindSecretID] = v.(bool)
		}

		if v, ok := d.GetOk(consts.FieldSecretIDNumUses); ok {
			data[consts.FieldSecretIDNumUses] = v.(int)
		}

		if v, ok := d.GetOk(consts.FieldSecretIDTTL); ok {
			data[consts.FieldSecretIDTTL] = v.(int)
		}

		if v, ok := d.GetOk(consts.FieldSecretIDBoundCIDRs); ok {
			data[consts.FieldSecretIDBoundCIDRs] = v.(*schema.Set).List()
		}
		//This can only be set during role creation and once set, it can't be reset later.
		if v, ok := d.GetOkExists(consts.FieldLocalSecretIDs); ok {
			data[consts.FieldLocalSecretIDs] = v.(bool)
		}
	} else {
		if d.HasChange(consts.FieldBindSecretID) {
			data[consts.FieldBindSecretID] = d.Get(consts.FieldBindSecretID).(bool)
		}

		if d.HasChange(consts.FieldSecretIDNumUses) {
			data[consts.FieldSecretIDNumUses] = d.Get(consts.FieldSecretIDNumUses).(int)
		}

		if d.HasChange(consts.FieldSecretIDTTL) {
			data[consts.FieldSecretIDTTL] = d.Get(consts.FieldSecretIDTTL).(int)
		}

		if d.HasChange(consts.FieldSecretIDBoundCIDRs) {
			data[consts.FieldSecretIDBoundCIDRs] = d.Get(consts.FieldSecretIDBoundCIDRs).(*schema.Set).List()
		}
		if d.HasChange(consts.FieldLocalSecretIDs) {
			data[consts.FieldLocalSecretIDs] = d.Get(consts.FieldLocalSecretIDs).(bool)
		}

	}
}

func approleAuthBackendRoleCreate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client, e := provider.GetClient(d, meta)
	if e != nil {
		return diag.FromErr(e)
	}

	backend := d.Get(consts.FieldBackend).(string)
	role := d.Get(consts.FieldRoleName).(string)

	path := approleAuthBackendRolePath(backend, role)

	log.Printf("[DEBUG] Writing AppRole auth backend role %q", path)

	diags := diag.Diagnostics{}

	data := map[string]interface{}{}
	approleAuthBackendRoleUpdateFields(d, data, true)

	_, err := client.Logical().Write(path, data)
	if err != nil {
		diags = append(diags,
			diag.Diagnostic{
				Severity: diag.Error,
				Summary:  fmt.Sprintf("error writing AppRole auth backend role %q: %s", path, err),
			},
		)
		return diags
	}

	d.SetId(path)
	log.Printf("[DEBUG] Wrote AppRole auth backend role %q", path)

	if v, ok := d.GetOk(consts.FieldRoleID); ok {
		log.Printf("[DEBUG] Writing AppRole auth backend role %q RoleID", path)
		_, err := client.Logical().Write(path+"/role-id", map[string]interface{}{
			consts.FieldRoleID: v.(string),
		})
		if err != nil {
			diags = append(diags,
				diag.Diagnostic{
					Severity: diag.Error,
					Summary:  fmt.Sprintf("error writing AppRole auth backend role %q's RoleID: %s", path, err),
				},
			)
			return diags
		}

		log.Printf("[DEBUG] Wrote AppRole auth backend role %q RoleID", path)
	}

	return append(diags, approleAuthBackendRoleRead(ctx, d, meta)...)
}

func approleAuthBackendRoleRead(_ context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client, e := provider.GetClient(d, meta)
	if e != nil {
		return diag.FromErr(e)
	}

	path := d.Id()

	backend, err := approleAuthBackendRoleBackendFromPath(path)
	if err != nil {
		return diag.Errorf("invalid path %q for AppRole auth backend role: %s", path, err)
	}

	role, err := approleAuthBackendRoleNameFromPath(path)
	if err != nil {
		return diag.Errorf("invalid path %q for AppRole auth backend role: %s", path, err)
	}

	log.Printf("[DEBUG] Reading AppRole auth backend role %q", path)
	resp, err := client.Logical().Read(path)
	if err != nil {
		return diag.FromErr(err)
	}
	log.Printf("[DEBUG] Read AppRole auth backend role %q", path)
	if resp == nil {
		log.Printf("[WARN] AppRole auth backend role %q not found, removing from state", path)
		d.SetId("")
		return nil
	}

	if err := d.Set(consts.FieldBackend, backend); err != nil {
		return diag.FromErr(err)
	}

	if err := d.Set(consts.FieldRoleName, role); err != nil {
		return diag.FromErr(err)
	}

	if err := readTokenFields(d, resp); err != nil {
		return diag.FromErr(err)
	}

	if v, ok := resp.Data[consts.FieldSecretIDBoundCIDRs]; ok {
		if err := d.Set(consts.FieldSecretIDBoundCIDRs, v); err != nil {
			return diag.FromErr(err)
		}
	}

	for _, k := range []string{consts.FieldBindSecretID, consts.FieldSecretIDNumUses, consts.FieldSecretIDTTL} {
		if err := d.Set(k, resp.Data[k]); err != nil {
			return diag.FromErr(err)
		}
	}

	if v, ok := resp.Data[consts.FieldLocalSecretIDs]; ok {
		if err := d.Set(consts.FieldLocalSecretIDs, v); err != nil {
			return diag.FromErr(err)
		}
	}

	log.Printf("[DEBUG] Reading AppRole auth backend role %q RoleID", path)
	resp, err = client.Logical().Read(path + "/role-id")
	if err != nil {
		return diag.Errorf("error reading AppRole auth backend role %q RoleID: %s", path, err)
	}
	log.Printf("[DEBUG] Read AppRole auth backend role %q RoleID", path)
	if resp != nil {
		if err := d.Set(consts.FieldRoleID, resp.Data[consts.FieldRoleID]); err != nil {
			return diag.FromErr(err)
		}
	}

	diags := checkCIDRs(d, TokenFieldBoundCIDRs)

	return diags
}

func approleAuthBackendRoleUpdate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client, e := provider.GetClient(d, meta)
	if e != nil {
		return diag.FromErr(e)
	}

	path := d.Id()

	log.Printf("[DEBUG] Updating AppRole auth backend role %q", path)

	data := map[string]interface{}{}
	approleAuthBackendRoleUpdateFields(d, data, false)

	_, err := client.Logical().Write(path, data)

	d.SetId(path)

	diags := diag.Diagnostics{}
	if err != nil {
		return diag.Errorf("error updating AppRole auth backend role %q: %s", path, err)
	}
	log.Printf("[DEBUG] Updated AppRole auth backend role %q", path)

	if d.HasChange(consts.FieldRoleID) {
		log.Printf("[DEBUG] Updating AppRole auth backend role %q RoleID", path)
		_, err := client.Logical().Write(path+"/role-id", map[string]interface{}{
			consts.FieldRoleID: d.Get(consts.FieldRoleID).(string),
		})
		if err != nil {
			return diag.Errorf("error updating AppRole auth backend role %q's RoleID: %s", path, err)
		}
		log.Printf("[DEBUG] Updated AppRole auth backend role %q RoleID", path)
	}

	return append(diags, approleAuthBackendRoleRead(ctx, d, meta)...)
}

func approleAuthBackendRoleDelete(_ context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client, e := provider.GetClient(d, meta)
	if e != nil {
		return diag.FromErr(e)
	}

	path := d.Id()

	log.Printf("[DEBUG] Deleting AppRole auth backend role %q", path)
	_, err := client.Logical().Delete(path)
	if err != nil {
		if util.Is404(err) {
			log.Printf("[DEBUG] AppRole auth backend role %q not found, removing from state", path)
			d.SetId("")
			return nil
		} else {
			return diag.Errorf("error deleting AppRole auth backend role %q, err=%s", path, err)
		}
	}

	log.Printf("[DEBUG] Deleted AppRole auth backend role %q", path)

	return nil
}

func approleAuthBackendRolePath(backend, role string) string {
	return "auth/" + strings.Trim(backend, "/") + "/role/" + strings.Trim(role, "/")
}

func approleAuthBackendRoleNameFromPath(path string) (string, error) {
	if !approleAuthBackendRoleNameFromPathRegex.MatchString(path) {
		return "", fmt.Errorf("no role found")
	}
	res := approleAuthBackendRoleNameFromPathRegex.FindStringSubmatch(path)
	if len(res) != 2 {
		return "", fmt.Errorf("unexpected number of matches (%d) for role", len(res))
	}
	return res[1], nil
}

func approleAuthBackendRoleBackendFromPath(path string) (string, error) {
	if !approleAuthBackendRoleBackendFromPathRegex.MatchString(path) {
		return "", fmt.Errorf("no backend found")
	}
	res := approleAuthBackendRoleBackendFromPathRegex.FindStringSubmatch(path)
	if len(res) != 2 {
		return "", fmt.Errorf("unexpected number of matches (%d) for backend", len(res))
	}
	return res[1], nil
}
